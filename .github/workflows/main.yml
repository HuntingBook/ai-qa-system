name: CI/CD for AI QA System

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test-backend:
    name: Build and Test Backend Services
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        working-directory: ./backend-services
        run: mvn -B clean package
        
  build-and-push-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest

    needs: build-and-test-backend
    
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Get Git commit hash
        id: git_info
        run: |
          echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3 

      - name: Build and push API Gateway image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-services
          file: ./backend-services/api-gateway/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-api-gateway:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-api-gateway:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Build and push User Service image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-services
          file: ./backend-services/user-service/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-user-service:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-user-service:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Build and push QA Service image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-services
          file: ./backend-services/qa-service/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-qa-service:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-qa-service:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./ai-chatbot
          file: ./ai-chatbot/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-frontend:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/ai-qa-frontend:${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          NACOS_SERVER_ADDR: ${{ secrets.NACOS_SERVER_ADDR }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DEPLOY_VERSION: ${{ steps.git_info.outputs.SHORT_SHA }}-${{ steps.git_info.outputs.TIMESTAMP }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.EC2_PORT || 22 }}
          timeout: 600s
          command_timeout: 600s
          envs: NACOS_SERVER_ADDR,GEMINI_API_KEY,JWT_SECRET,DOCKERHUB_USERNAME,DEPLOY_VERSION
          script: |
            set -euo pipefail

            # 创建 .env 文件来管理环境变量
            cat > ~/ai-qa-system/.env << EOF
            # MySQL configuration
            MYSQL_ROOT_PASSWORD=ai_qa_system
            MYSQL_DATABASE=ai_qa_system
            MYSQL_USER=ai_user
            MYSQL_PASSWORD=ai_user_pass

            # Nacos server address
            NACOS_SERVER_ADDR=${NACOS_SERVER_ADDR}

            # JWT secret shared across services
            JWT_SECRET=${JWT_SECRET}

            # Gemini API key
            GEMINI_API_KEY=${GEMINI_API_KEY}

            # Docker Hub username for pulling images
            DOCKERHUB_USERNAME=${DOCKERHUB_USERNAME}

            # Frontend base URL (for client-side requests)
            FRONTEND_API_BASE_URL=http://api-gateway:8083

            # Deployment version
            DEPLOY_VERSION=${DEPLOY_VERSION}
            EOF

            if [ ! -d "${HOME}/ai-qa-system" ]; then
              echo "Cloning repository..."
              git clone https://github.com/${{ github.repository }} "${HOME}/ai-qa-system"
            else
              echo "Repository exists, updating..."
            fi

            cd "${HOME}/ai-qa-system"

            # 确保在正确的分支上
            git fetch origin
            git checkout main
            git pull origin main

            # 最后设置 .env 文件权限
            chmod 600 "${HOME}/ai-qa-system/.env"

            # Use production compose file
            COMPOSE_FILE="docker-compose.prod.yml"

            # Check if production compose file exists, if not fall back to regular compose file
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "Production compose file not found, using docker-compose.yml"
              COMPOSE_FILE="docker-compose.yml"
            fi

            echo "Using compose file: $COMPOSE_FILE"
            echo "Deployment version: ${DEPLOY_VERSION}"

            # 安全地停止现有容器
            echo "Stopping existing containers..."
            if docker compose -f $COMPOSE_FILE ps -q | grep -q .; then
              docker compose -f $COMPOSE_FILE down --remove-orphans || true
            fi

            # 清理未使用的资源
            echo "Cleaning up Docker resources..."
            docker system prune -f --volumes || true

            # 拉取最新镜像
            echo "Pulling latest images..."
            docker compose -f $COMPOSE_FILE pull

            # 启动服务
            echo "Starting services..."
            docker compose -f $COMPOSE_FILE up -d --remove-orphans

            # 等待服务启动
            echo "Waiting for services to start..."
            sleep 30

            # 验证服务状态
            echo "Checking service status..."
            docker compose -f $COMPOSE_FILE ps

            # 清理旧镜像
            echo "Cleaning up old images..."
            docker image prune -f

            echo "Deployment completed successfully!"

            # 显示服务健康检查端点
            echo "Service endpoints:"
            echo "Frontend: http://${{ secrets.EC2_HOST }}:3000"
            echo "API Gateway: http://${{ secrets.EC2_HOST }}:8083/swagger-ui.html"